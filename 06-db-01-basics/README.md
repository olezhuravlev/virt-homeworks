# Домашнее задание к занятию "6.1. Типы и структура СУБД"

---

## Задача 1

Архитектор ПО решил проконсультироваться у вас, какой тип БД лучше выбрать для хранения определенных данных.

Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:

- Электронные чеки в json виде
- Склады и автомобильные дороги для логистической компании
- Генеалогические деревья
- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации
- Отношения клиент-покупка для интернет-магазина

Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

===

**Электронные чеки в json виде**

В зависимости от протребностей это м.б.:
- какая-либо реляционная СУБД с возможностью хранения json в поле таблицы (например, PostreSQL или OracleDB) и создавать индексы по таким полям (например, по номеру чека). Также здесь можно установить взаимосвязь с другими сущностями, например, с номенклатурой товаров, что важно в целях товарного учёта;
- документоориентированная NoSQL позволяющая хранить слабоструктурированные данные, в т.ч. в виде JSON-структур.

**Склады и автомобильные дороги для логистической компании**
  - Здесь можно применить графовую СУБД, поскольку дорожная сеть сама по себе является графом;

**Генеалогические деревья**
  - иерархическая СУБД, обладающая естественными отношениями "родитель-наследник";

**Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации**
  - Здесь применима СУБД вида "key-value" (например Redis или Memcached), имеющие механизм Time-To-Live; 

**Отношения клиент-покупка для интернет-магазина**
  - реляционная СУБД будет удобна, посколько обеспечивает взаимосвязь документов, оформляющих жизненный цикл "купли-продажи" (накладные на поставку, оплата поставщику, накладные на перемещение между складами, получение оплаты от покупателя, отгрузка покупателю и т.д.).

---

## Задача 2

Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система, если (каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию):

- Данные записываются на все узлы с задержкой до часа (асинхронная запись)
- При сетевых сбоях, система может разделиться на 2 раздельных кластера
- Система может не прислать корректный ответ или сбросить соединение

А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

===

**Приложения можно классифицировать следующим образом:**

|                                                                           | По CAP                                                                                                                                                                                                            | По PACELC                                                                        |
|:--------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Данные записываются на все узлы с задержкой до часа (асинхронная запись)  | CP (данные записываются на все узлы, и, очевидно, они согласованы)<br/>AP (в зависимости от требований такая задержка м.б. приемлемой и тогда условие Доступности (Availability) будет считаться удовлетворенным) | PC (системая является разделяемой, но задержки велики)                           |
| При сетевых сбоях, система может разделиться на 2 раздельных кластера     | AP (условие Partition Tolerance однозначно удовлетворено, а "сетевые сбои" устраняются таковым разделением что обеспечивает критерий Доступности)                                                                | PA (система является разделяемой, и, по-видимому, это обеспечивает  доступность) |
| Система может не прислать корректный ответ или сбросить соединение        | PC (Availability не удовлетворено)                                                                                                                                                                                | EC (разделяемости, похоже, здесь нет, как и удовлетворение критерию Latency)     |



---

## Задача 3

Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

===

ACID-модель делает упор на согласованности, а BASE-модель - на доступности данных.
С учётом того, что согласование данных требует времени и это неизбежно сказывается на доступности данных, эти модели противопоставляются друг-другу и полностью сочетаться в одной системе не могут.

---

## Задача 4

Вам дали задачу написать системное решение, основой которого бы послужили:

- фиксация некоторых значений с временем жизни
- реакция на истечение таймаута

Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
Что это за система? Какие минусы выбора данной системы?

===

Механизм "Публикатор-Подписчик" является реализацией архитектурного паттерна "Наблюдатель" (Observer) и реализован, например, в такой СУБД, как Redis. Кроме того, Redis имеет механизм контроля времени жизни сущности (Time-To-Live).

Вместе с тем Redis присущ ряд недостатков:
- размер базы данных ограничен имеющейся RAM;
- ограниченные возможности по контролю доступа к базе данных (нет сегментации на пользователей или группы пользователей);
- Redis может хранить только текстовые данные, соответственно, повышаются накладные расходы на сериализацию/десериализацию;
- во время взаимодействие Redis с жестким диском Latency существенно повышается, кроме того, Redis вообще недоступен пока состояние после сбоя не будет полностью восстановлено с диска;
- является отсутствие механизма консенсуса по-умолчанию и выбор ведущей реплики, возможно, придется делать вручную.


Т.о. Redis лучше не использовать для хранения чувствительных данных или данных, без которых работа системы невозможна.

Кроме того, использование Redis может оказаться просто избыточным для поставленных задач и, возможно, стоит рассмотреть иную реализацию требуемого функционала (например, разработать собственное приложение).

---
